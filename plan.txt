
Engine is the main game. It runs a secure VM and provides acceleration for slow operations and I/O.
Mod loader finds and selects resources and resolves conflicts. The final mod is placed in the main game directory.
Server browser finds servers and sends the selected one to the engine.
Supervisor runs each application and moves the necessary data between them.

Order of implementation:
    Engine - Game
    Mod loader
    Server browser
    Supervisor

VM
    What we want to avoid:
        Access to the file system
        Access to external programs
        Access to the internet
        Spyware
    Languages
        QVM
            Works, but is binary, uses a niche compiler, and doesn't allow stacked mods.
        Java
            ?
        Python
            Not easily sandboxed? I should learn Python.
        LLVM
            Not easily sandboxed?
        Custom bytecode
            GCC/LLVM -> bytecode -> safe interpreter
        ECMAScript
            Every number is a float. I don't like it.

Pre-game
    Restricted variables can be set using pipe.
    Game code is loaded.
In-game
    Nearly any variable can be set and read.

Server will know the whole game state. Client will (ideally) only know what it can see. As much client information as practically possible should be presented to the player. This is an anti-cheat measure.

The client will setup the I/O, and then run the game script. The script will periodically call functions that the client provides.
The server will run the game script. The script will periodically call functions that the server provides.
The script is somewhat in charge of the framerate. I may or may not change that in the future. We don't want people mining Bitcoin in other people's game.

I'm thinking of keeping all geometry inside the engine. I don't think the game code needs it, and it would be a hassle to transfer it to Lua. If the game code needs a normal, I'll let it have the normal. It doesn't need any more than that though. All collision detection will be done in the engine itself.

Do *any* config, lock restricted settings, start lua, do limited config

Client system calls
    get_user_input
        Keyboard, mouse, and joystick
    add_entity
        Tell renderer to try drawing this entity.
    render_scene
    get_server_state
        Get the server state from the network, named pipe, or carrier pigeon.
    send_client state
        Send the client state using the network, named pipe, or carrier pigeon.
Server systems calls
    get_client_state
        Get the client state from the network, named pipe, or carrier pigeon.
    send_server_state
        Send the server state using the network, named pipe, or carrier pigeon.
    load_map
        Load the map into the given entity tree.

Lua may not execute config scripts, however, it may set config variables that it has permissions for.

Screenshots and videos both save as a dump of the game state. These game states can then be converted to images or videos.

Console will be fully integrated into the engine. No part of it will be in Lua. Lua can access the variables, but it cannot run commands.

Client config vars will be initialized to whatever is required, but the server will then send additional vars to create. If a var already exists, it will be overwritten.

The entity tree is created not by the engine, but by the Lua script. This allows for the script to either load a map from a file, or do something fancier like procedurally generate the map.
All objects are stored in a global array.
All materials are stored in a global array.

Required calls to manage the entity tree:
    bool l_fileExists(string fileName)
        Return true if file "fileName" exists.
    string l_getFileContents(string fileName)
        Return the contents of file "fileName".
    {int objectIndex, string objectName} l_loadOBJ(string fileName)
        Load OBJ file into engine. Returns the object array index and the object name. Index is -1 on error.
        MTL is loaded automatically if one is requested and exists.
    int l_entity_create(string name, int type)
        Adds an entity of name "name" and type "type". Returns the index.
    bool l_entity_delete(int index)
        Returns true if entity at index was successfully deleted.
    bool l_entity_addChild(int parent, int child)
        The index "child" will refer to the appropriate list based on the type of the parent entity.
        If entities can be linked and the operation is successful, then this function returns true.
        If the entities cannot be linked (possibly because of a hirarchy loop), this function returns false.
    bool l_entity_removeChild(int parent, int child)
        If entities can be unlinked and the operation is successful, then this function returns true.
        If entities cannot be unlinked (possibly because they weren't linked in the first place), then this function returns false.
    int l_loadOoliteModel(string fileName)

entity {
    int type
    void *children
    int children_length
    string_t name
    vec3_t origin
    vec4_t orientation
}

Communicating the game state must be fast. All other communications can occur slowly.

Server â†’ client gamestate commands
    Create entity
    Delete entity
    Set entity

The above command list will be implemented in Lua. Determining what to send the client will be Lua's job. The packaging of it will be the engine's job.

After a map is loaded, the game state of both the client and the server should be the same. Diffs will then be sent to the client when appropriate.

I need to use UDP because it is real time, while TCP may do weird things with time. I'm essentially going to write my own ripped-off version of Carmack's protocol.

Server send
    C: Subtract most recently acknowledged state from current state.
    C: Place current state in queue.
    C: Compress difference.
    C: Send compressed difference.
Server receive
    C: Receive compressed difference.
    C: Inflate difference.
    C: Place difference in queue.
    C: Add current state to 



Files to rewrite when it is somewhat working:
    obj
    file
    vfs
    str
    cfg (maybe)

[/] (Client) Get something on the screen using SDL
--------------------------------------------------
[*] (Client) Call C functions from Lua
[*] (Server) Call C functions from Lua
-----------------------------------------------
[*] (Common) Load and parse Wavefront OBJ files
[*] (Common) Load and parse config files
[*] (All)    Get on those TODOs (ugly ones)
[/] (Common) Create virtual file system
    [*] (Common) Create file_concatenatePath()
    [*] (Common) Only allow file paths that remain in the workspace
[/] (Common) Load and parse Wavefront MTL files
[ ] (Common) Create entity tree from Lua
[ ] (Server) Send entity tree over the network
    [ ] (All) Decide on network protocol
[ ] (Client) Receive entity tree from the network
[ ] (All)    Get on those TODOs (ugly ones)
[ ] (Client) Render entity tree in basic 3D using OpenGL
-------------------------------------------------------------
[ ] (Client) Pass entity tree through VM and back to renderer
[ ] (Server) Send entity tree every second
[ ] (Server) Animate entity tree
[ ] (All)    Get on those TODOs (ugly ones)
[ ] (Client) Render tree every time it is received
--------------------------------------------------
[/] (Client) Get keyboard input
[/] (Client) Get mouse input
[ ] (Client) Send input
[ ] (All)    Get on those TODOs (ugly ones)
[ ] (Server) Receive input
[ ] (Server) Make an entity move based on input
-----------------------------------------------
[ ] (Client) Attach camera to moving entity
-------------------------------------------
