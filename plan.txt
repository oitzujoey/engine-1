@TODO: Lines marked with an exlamation point in the first column are out-of-date.


@TODO: Lines like this need to be fixed eventually.
@PLATFORM_DEPENDENT: Lines marked like this need to be rewritten to be platform independent.


Engine is the main game. It runs a secure VM and provides acceleration for slow operations and I/O.
Mod loader finds and selects resources and resolves conflicts. The final mod is placed in the main game directory.
Server browser finds servers and sends the selected one to the engine.
Supervisor runs each application and moves the necessary data between them.

Order of implementation:
    Engine - Game
        Server - Client
        Sgame - Cgame
    Supervisor
    Master server
    Server browser
    Mod loader

VM
    What we want to avoid:
        Access to the file system
        Access to external programs
        Access to the internet
        Spyware
    Languages
        QVM
            Works, but is binary, uses a niche compiler, and doesn't allow stacked mods.
        Java
            ?
        Python
            Not easily sandboxed? I should learn Python.
        LLVM
            Not easily sandboxed?
        Custom bytecode
            GCC/LLVM -> bytecode -> safe interpreter
        ECMAScript
            Every number is a float. I don't like it.

Pre-game
    Restricted variables can be set using pipe or arguments.
    Game code is loaded.
In-game
    Nearly any variable can be set and read.

Server will know the whole game state. Client will (ideally) only know what it can see. As much client information as practically possible should be presented to the player. This is an anti-cheat measure.

The client will setup the I/O, and then run the game script. The script will periodically call functions that the client provides.
The server will run the game script. The script will periodically call functions that the server provides.
!The script is somewhat in charge of the framerate. I may or may not change that in the future. We don't want people mining Bitcoin in other people's games.

I'm thinking of keeping all geometry inside the engine. I don't think the game code needs it, and it would be a hassle to transfer it to Lua. If the game code needs a normal, I'll let it have the normal. It doesn't need any more than that though. All collision detection will be done in the engine itself.

Do *any* config; lock restricted settings; start lua; do limited config

!Client system calls
!    get_user_input
!        Keyboard, mouse, and joystick
!    add_entity
!        Tell renderer to try drawing this entity.
!    render_scene
!    get_server_state
!        Get the server state from the network, named pipe, or carrier pigeon.
!    send_client state
!        Send the client state using the network, named pipe, or carrier pigeon.
!Server systems calls
!    get_client_state
!        Get the client state from the network, named pipe, or carrier pigeon.
!    send_server_state
!        Send the server state using the network, named pipe, or carrier pigeon.
!    load_map
!        Load the map into the given entity tree.

!Lua may not execute config scripts, however, it may set config variables that it has permissions for.

Screenshots and videos both save as a dump of the game state. These game states can then be converted to images or videos.
    It would be really cool to be able to take a screenshot and then render it later using ray tracing.

!Console will be fully integrated into the engine. No part of it will be in Lua. Lua can access the variables, but it cannot run commands.

Client config vars will be initialized to whatever is required, but the server will then send additional vars to create. If a var already exists, it will be overwritten.

Client will know its own number.

The entity tree is created not by the engine, but by the Lua script. This allows for the script to either load a map from a file, or do something fancier like procedurally generate the map.
All objects are stored in a global array.
All materials are stored in a global array.


No entity truly contains any other entity. It may contain the addresses of several child entities, but the children will always be stored in the entity list.
Models may be treated as a child entity, but they cannot contain other entities and may not be placed in the entity list.
The entity list exists to keep track of all entities. It should prevent permanently lost entities that are unable to be freed, and it allows the game state to be sent to the client more easily and compactly. Once an entity is created, it will never be destroyed. It may be completely unlinked and placed on the deleted-entity list, but it will not be freed. When a new entity is asked for, the deleted-entity list will be checked first. If an entity is in that list, it will be resurrected and removed from that list. If the deleted-entity list is empty, a new entity will be created using malloc. Only during shutdown will the entities in the entity list be freed.
Models may be created, but not freed until game shutdown.

Lists:
    entity_t *world_g;
    model_t *model_g;

entity world_g {
    void *entities {
        entity {
            void *entities {
                entity ...,
                ooliteModel {
                    vec3_t *vertices;
                    int vertices_length;
                    vec3_t *faces;
                    int faces_length;
                    vec3_t *surfaceNormals; // Same length as "faces".
                }
            };
            int entities_length;
        },
        ...
    };
    int entities_length;
    subEntityType_t type[none, entity, ooliteModel] = entity;
}

Oolite .dat file format:
    NVERTS <number of vertices>
    NFACES <number of faces>
    
    VERTEX
    <(float[3]) vertex>
    ...
    
    FACES
    0 0 0 <(float[3]) face normal> || <"0 0 0"> 3 <(int[3]) vertex indices>
    ...
    
    TEXTURES
    <Texture index> 1.0 1.0 <(float[2]) texture coordinates[0]> <(float[2]) texture coordinates[1]> <(float[2]) texture coordinates[2]>
    ...
    
    NAMES <number of names>
    <Material name>
    ...
    
    NORMALS
    <(float[3]) normal>
    
    END



Required calls to manage the entity tree:
    bool l_fileExists(string fileName)
        Return true if file "fileName" exists.
    string l_getFileContents(string fileName)
        Return the contents of file "fileName".
    {int objectIndex, string objectName} l_loadOBJ(string fileName)
        Load OBJ file into engine. Returns the object array index and the object name. Index is -1 on error.
        MTL is loaded automatically if one is requested and exists.
    int l_entity_create(string name, int type)
        Adds an entity of name "name" and type "type". Returns the index.
    bool l_entity_delete(int index)
        Returns true if entity at index was successfully deleted.
    bool l_entity_addChild(int parent, int child)
        The index "child" will refer to the appropriate list based on the type of the parent entity.
        If entities can be linked and the operation is successful, then this function returns true.
        If the entities cannot be linked (possibly because of a hirarchy loop), this function returns false.
    bool l_entity_removeChild(int parent, int child)
        If entities can be unlinked and the operation is successful, then this function returns true.
        If entities cannot be unlinked (possibly because they weren't linked in the first place), then this function returns false.
    int l_loadOoliteModel(string fileName)

entity {
    int type
    void *children
    int children_length
    string_t name
    vec3_t origin
    vec4_t orientation
}

Communicating the game state must be fast. All other communications can occur slowly.

Server → client gamestate commands
    Create entity
    Delete entity
    Set entity

!The above command list will be implemented in Lua. Determining what to send the client will be Lua's job. The packaging of it will be the engine's job.

After a map is loaded, the game state of both the client and the server should be the same. Diffs will then be sent to the client when appropriate.

I need to use UDP because it is real time, while TCP may do weird things with time. I'm essentially going to write my own ripped-off version of Carmack's protocol.

Server send
    C: Subtract most recently acknowledged state from current state.
        Subtraction should result in changes only and static values should cancel to zero. We need a protocol that has this characteristic.
    C: Place current state in queue.
    C: Compress difference.
    C: Send compressed difference.
Server receive
    C: Receive compressed difference.
    C: Inflate difference.
    C: Place difference in queue.
    C: Add current state to 


Coordinate system:
    vec3 is specified by "x,y,z".
    quat is specified by "w,x,y,z".
    1,0,0 points horizontally along the x axis.
    0,1,0 points horizontally along the y axis.
    0,0,1 points vertically along the z axis.
    Camera:
        1,0,0,0 points along the x axis. Camera x axis is along the y axis. Camera y axis is along the z axis. This only applies for the 1,0,0,0 orientation.


sgame will tell server what models to load. server will tell client what models to load. cgame might be able to check what models are loaded.


~100 packets/second - Determined by server variable. Server will send this value to the client.
~1000 millisecond timeout - Determined by server variable. Server will send this value to the client.
1400 MTU - Determined by server and client variables.

UDPv4 {
    16'source_port
    16'destination_port
    16'length
    16'checksum
    ?8'data
}

flags {
    1'encrypted
    1'compressed
    1'subtracted
}

server_data {
    8'command
}

client_data {
    8'command
}

server_header {
    16'id
    16'id_ack
    16'flags
    ?8'server_data
}

client_header {
    16'id
    16'id_ack
    16'flags
    ?8'client_data
}

if server {
    UDPv4.data:server_header
}

if client {
    UDPv4.data:client_header
}

Client commands:
    Dummy
    Join
    Set game input [float mouseX] [float mouseY] [bool keys[]] // The length of keys is NUMBER_OF_KEYS
    Disconnect
    Server console command [char command[]]
    Raw to lua [uint8_t message[]]
    Error
    
Server commands:
    Dummy
    Negotiate private key
    Enable encryption
    Set entity state [entityList_t entityList] [entity_t entityList.entities[]] [int entityList.deletedEntities[]] // Length of both arrays is stored in the entity list.
    Play sound [int soundNumber]
    Client console command [int length] [char command[]] // Not null terminated
    Raw to lua [int length] [uint8_t message[]] // Not null terminated
    Error

Dummy commands are too keep the connection alive when no data is being sent.
id_ack is the id of the message that is being referenced by the sender. The receiver must add this message to the just received one.
id & id_ack start at 0 and count up to ID_MAX. The value will then overflow to zero. ID_MAX and the timeout must be chosen such that id will not cycle through the entire sequence before a timeout occurs.
All out-of-order packets will be mercilessly discarded.
If a timeout occurs, 

init
    send "hello"
    negotiate key

send data
    message = send_queue.pop()
    sent_messages.push(message)
    message = subtract(message, last_acknowledged(received_messages))
    compress message
    encrypt message
    send message
    
receive data
    receive message
    decrypt message
    inflate message
    message = add(message, sent_messages[message.id_ack])
    set_acknowledge(received_messages[message.id_ack])
    received_messages.push(message)

Order is important. If the fields aren't set in the proper order, the subtraction trick won't work.
0.  Headers + Flags
<Start encryption>
1.  Entity state
*.  Misc commands
<End encryption>
-0. Signature

Lag compensation techniques:
    None:
        client0 r0      r1
        client1 r1      r0
        server     r0r1

Layer 0:    UDP
Layer 1:    Encryption
Layer 2:    Reliable packet transmission
Layer 3:    Compression

Entities will be sent to the client using unreliable packets. Everything else will be sent using reliable packets.
Key presses will be sent to the server using unreliable packets. Everything else will be sent using reliable packets.


The purpose of config scripts is to set variables required to get the game running.
The purpose of the console is to do basic configuration of the client and server, however, making it an extensive debugging tool will also be a priority. 


Server discovery will happen over TCP.

It might be a good idea to use entity 0 (world) to orient the camera. The client would set the position and orientation of entity 0, and the renderer would automatically render the correct view.

Perhaps I should use a uniform variable when passing the orientation to the vertex shader. I don't really need ~1000 copies of the same vector. That should reduce orientation overhead nearly to zero.

I might need a new type of model to store hitboxes/clip models in.

Player is the center of the universe and always looks in the same direction.

Allow multiple viewports using what are essentially copies of the world entity. This will be known as a camera object and will be another entity child type.

There will be one Lua script that is called once every game cycle. Startup can be detected by checking to see if a variable is undeclared. The startup script can then set that variable to prevent rerunning the function.

Why I need a VFS:
    File path sanitization
    File archive management
Why I should make my own:
    Smaller
    Does exactly what I want
    One less dependency
Why I should use someone else's:
    Less development time
    Supports more formats
    Does nearly exactly what I want

/
    home/user/.engine-1 (workspace)
        <game-created files>
    usr/local/
        bin/
            engine-1 (bash)
            engine-1_server (bash)
        games/engine-1/
            autoexec.cfg
                ```
                workspace ~/.engine-1
                load
                lua lua/
                ifdef server exec config/server.cfg
                ifdef client exec config/client.cfg
                ```
            config/
                client.cfg
                server.cfg
            cengine-1.x86_64
            sengine-1.x86_64
            base/ (game files)
                lua/
                    cmain.lua
                    smain.lua
                    extra.lua
                models/
                autoexec.cfg

The workspace is the place where the game can read and write.
A mod is a directory with resources. If the engine finds Lua files that conflict, it will attempt to resolve the conflicts. If it fails, it will print an error declaring the mods incompatible and exit. If the engine finds config files that conflict, it will concatenate them together. All other files will be replaced by newer versions.
PhysFS cannot do this. The proposed workaround is to either deal with that fact, or read the sensitive files into memory before other mods are loaded. The latter should work.
Every time a mod is loaded:
    Config files are merged.
    Lua files are stored in memory. Right before game start, each {c,s}main.lua file is run to determine if any files are unmodified or unused. Duplicates of unmodified files are discarded. Each time a file is `include`ed it is marked as used. Unused files are then discarded. The remaining duplicate files are diffed and merged. If there is an original and a derivative, then the derivative replaces the original. If there are two derivatives, then a three way merge will be done to the the result. If there are more than three files, the three way merge will be done recursively. The original file will remain the original for the merge. The resulting file will become one of the derivative files. The other derivative file in the merge will be one of the other derivatives to merge.
`exec` and friends will check if *.cfg is stored in memory before checking on the file system.

1.  Mount engine directory.
2.  Execute autoexec.cfg
    1.  Set workspace.
3.  Unmount engine directory.
5.  Load original mod (original game).
    1.  Store "*.cfg" and "*.lua" in memory and mark as originals.
6.  Load additional mods.
    1.  Store "*.cfg" and "*.lua" in memory and mark as duplicates.
7.  Merge "*.cfg"s.
    1. Execute "autoexec.cfg"
8.  Execute "*.lua"s and discard "*.lua"s that never get called. Reset luaState.
9.  Merge "*.lua"s.
    1.  Perform three way merge.
    2.  Repeat (1) until all files have been merged with the original.
10. Load "*.lua" into luaState.
11. Game start.

ALL file I/O will go through PhysFS. The original autoexec in the engine directory will be run by temporarally mounting the engine directory. After the autoexec is run, the directory is then unmounted.

Every game tick, ?main.lua is run. Right before the script is run, SDL events are dealt with. If there is a keyboard, mouse, etc. event, the input table in Lua will be filled with the result of these events.


!I'm tempted to send the whole SDL_event structure to Lua.
^^^ That's not how it works. It's a union.

Lua:
keys[]
axes[{
    value: integer
    type: ("mouse", "joystick", "controller")
}]

axes[0] and axes[1] are mouse x and mouse y.

Key binding will be done in the engine using the `bind` command.
    bind mouse2 moveup
    bind mouse2 moveup moveup
    1.  Lua creates a control variable. When the variable is set, Lua will know to do an action.
    2.  Bind that variable to a key. When that key is pressed, the variable is set. When the key is released, the variable is cleared. If a second variable is given, then only that variable will be cleared.
    3.  Lua does something with that variable. It is possible that setting the variable runs a Lua function.

`vstr` is going to be a must. A prerequisite for this is putting multiple commands on one line, putting strings and subcommands in quotes, and escaping quotes and linebreaks.

# A primitive rocket jump script.
command rocketJump_d moveup 1, attack 1
command rocketJump_u moveup 0, attack 0
# Since a command is executed, no variable is set or cleared.
bind mouse3 rocketJump_d rocketJump_u

!# When rail is selected, kill mouse accel for the first shot, but add it afterward for an easy escape.
!bind w "weapon 7 ; sensitivity 1 ; cl_mouseAccel 0 ; bind mouse1 \"attack 1 ; sensitivity 1 ; cl_mouseAccel 0.3\" \"attack 0\""

!# This is valid, but `set` may return an error and/or not execute the scripts.
!set "set attack 1" "ifdef server exec extra.cfg"

What I got from this: Binding can be done in the engine, and Lua doesn't necessarily need to know the physical keys. I think I will let Lua peek at them anyway.
This is getting complicated.

!Commands marked with "`" will be executed before the rest of the command. They can be escaped.
!set `ifdef server return 2 ; ifdef client return 5`

Joysticks are given a number that corresponds to the order in which they are connected. Is this fine, or do I need to recognize/be told which joystick is in the right hand and which joystick is in the left hand? I could add a Lua function that can move joystick numbers around. Lua would ask the user to push a button on stick 0, stick 1, etc. and then reorder the sticks' numbers to keep the bindings correct.

Question for Josh: Do games normally remember which controller you used with which hand?

I might not add keybinding into the scripting language due to the complicated representation of buttons. I would have to give names to all the buttons. I think I'll try first and see if it works. I'll see if I can do it procedurally.

type
    k
    j
    c
    m
device (Joysticks and controllers only)
    <device number>
key
    <key code/key name/button index>

Naming format: <type><device>_<key>

Semicolons separate commands. Commas separate arguments in commands that accept scripts. These commas are then converted to semicolons when the argument is stored or executed. Think of it as lazy escaping, because that's essentially what it is. Quotes are too time consuming at the moment.

And networking again...
So far there is one stream: The server to client game state. I expect to completely redo that or figure out some way to use a structure instead.
It's time to add another stream: input. It is going to be implemented just like the server stream, but from client to server.
One of the problems that this presents that I will have to deal with soon is that the server needs to know when a message has been received. I may use a Lua callback like I did with key binding, but an event system like in Q3 and SDL could be used instead and would probably be faster. Polling is also an option.

I think sending input to the server will be simple. Just send an array of keypresses.

I've solved the problem I was having with the packet parser/generator. I really hate the idea of having to hard code the parser by repeating tons and tons of repetitive masking code. My idea is to make a function that does the parsing. Since each data type is different, there will also be a callback that is passed to it to parse that specific type. This should clean up what I've got quite a bit and hopefully fix some buffering related bugs.

I think callbacks are overkill here.

Should backwards reconciliation be done in the engine or in the gamecode? Let's try the gamecode first. Q3A did it in the gamecode, but it was probably faster than Lua.

Lua will send keys over an unreliable connection. The Client Lua will determine how to send the keys to the server Lua. I may add a function to convert a Lua table to a string. I may also have a "cnetwork_sendTable" function or something like that. All that function will do is add the data to an array that is then sent once per game cycle.
Instead of a "cnetwork_sendString" function, maybe I should simply create a table and then have Lua add to it. The server would receive the table, but the table will be inside an array that is indexed by the client number.

-- Client side:
{
    -- User table is here.
    keys: [
    
    ],
    say: [
        {
            recipients: [
                int
            ],
            message: string
        }
    ]
}

-- Server side:
clientState: [
    {
        -- User table is here.
        keys: [
        
        ],
        say: [
            {
                recipients: [
                    int
                ],
                message: string
            }
        ]
    }
]

size_t'nameLength
nameLength'name
1b'isArray 7b'type
if isArray {
	size_t'length
	(typeToSize[type]*length)'elements
}
else {
	typeToSize[type]'variable
}

table {
size_t'11
11B'"clientState"
1B'(0x00 | stringToType["table"])
size_t'??   // Length
headers...
}

array {
size_t'11
11B'"clientState"
1B'(0x80 | stringToType["byte"])
size_t'??   // Length
length'??   // Array of bytes
}

array {
size_t'11
11B'"clientState"
1B'(0x00 | stringToType["byte"])
1B'0x78
}

Data comes right after the header. This includes tables. In the case of a
table, the length specifies the number of headers+data that should be found.
The proper number of tables will then be iterated through. Other tables may
be contained in that table. This will be dealt with using recursion.

I don't know how to allocate this only once. I think I will have to
reallocate once per header encountered.

I want to both receive entities from the server, but I also want the client to be able to add its own. I think a good solution to this problem is to have a server entity list and a client entity list. Both are rendered by the client. This is to keep the server's constantly changing entities from messing up the client's entities' indices.
It seems like it may be a good idea to create a client entity type.

The keyboard to video latency is too slow. By this I mean that at no time should I have to wait a five seconds to get a response. Once the entity is moving, it seems like the throughput is reasonably good. It feels like there is a buffer in there somewhere that is inserting lag.
Buffers:
    enet internal send buffer
    enet internal receive buffer
    
cengine seems to be running too slow. I suspect that it is not receiving the entity list. It does not seem to be sending the keys either.
I think I figured out what is going on. It seems likely that my framerate is supposed to be 60 Hz. This is approximately equal to 16.67 ms. I have been trying to set the game cycle time to 10 ms. What is probably happening is that rendering is going to fast or something like that. I honestly don't know. 20 ms works just fine though, so I think I will change the default to that.

Lua should load the shaders if they are not built into the model format.

Time to project into 2D properly. I need the FOV and the aspect ratio. I think I will make the FOV a width instead of an angle. Actually, longest dimention of the screen is probably better.
Screen width will always be 1. Screen height will vary.

It would be interesting to not have any 2D sprites and use 3D for everything.

I need to project the vertex into 2D and then set the z-axis to place it in the right position relative to other models.

x ← vx/vz * 1
y ← vy/vz * height
z ← 1 - 2/z

(0, Inf) → (-1, 1)

The world should be the same from every client's perspective. The only difference between them is which entities are present and what position and orientation the world (really the player) is in. Since I want to keep every entity list as close to the same as possible, I will send the client position and orientation as a Lua table.

Server:
    number maxClients = MAX_CLIENTS
    table serverState[MAX_CLIENTS]
    table clientState[MAX_CLIENTS]
    function setup
    function main
    function shutdown
    function clientConnect(clientNumber)
    function clientDisconnect(clientNumber)

Client:
    table clientState
    table serverState
    function setup
    function main
    function shutdown
    function <keybind_callbacks>

The lag may have been caused by improperly running enet_host_service. At any rate, it seems to be gone now.

Time to add textures.
I think I will create a texture list, and entities will use textures from that list to avoid redundancy.
A material list will be required as well. Materials can have textures and special attributes.

materialList {
    {
        textureFile "", // Maybe.
        textureObject int
    },
    ...
}

`textureObject`s are indices to OpenGL textures. The texture itself will not be retained in memory for now.
Materials pointing to entities can result in dangling pointers. Entities pointing to materials will never result in a dangling pointer. Therefore we shall do the latter, though this means I have to modify the entity system.
Communication of materials will be communicated from the server to the client through `serverState`.

Runner should be able to run pretty much any mod. This provides a challenge for key binding since the keys can change between mods. A mod should provide a list of available key bindings. This should be in a file such as "keybinds.txt" or "runner.txt".
This brings up another interesting point. Ideally, the runner will be able to save state between runs. There should be a config.txt file that saves this state. runner.txt files in mods will be able to overwrite certain (but definitely not all) settings. One of the settings that can be overwritten are available key bindings. The binds themselves cannot be overwritten by the mod.
I might use cfg2 for the runner's config file format.

IMPORTANT NOTE: There is no texture list. OpenGL holds all the textures, so the only thing needed to use them is the index.

One index per texture.
One texture per material.
`numBindableMaterials` materials per model.
(* models) xor (* entities) per entity.


Bug:
    Start server.
    Connect client 1.
    Connect client 2.
    Disconnect client 1.
    Disconnect client 2.
    Connect client 1.
    Connect client 2.
    Disconnect client 1.
    Segmentation fault client 2.


A lot of entities are sent to the client. I don't believe there's a need for this. I should be able to send all the entities to the client once, and then only send updates for a subset of them.

Use something like message passing instead of what we currently have. Maybe have a `send_to_client` function or have an "incoming objects" queue.

We want to send server entities to the client.
We want to send Lua server objects to the client.
We want to send Lua client objects to the server.

Maybe I should just start with Lua objects.

sendObjectToClient(clientIndex, object)
sendObjectToServer(object)

serverState is owned by the server and sent to the client.
clientState is owned by the client and sent to the server.
clientState is an object on the client and an array of objects on the server.
serverState is an object.

So currently, the only change would be to not send the entity list to the client. Do I just clear visibility for that entity to do that? No. It sends all the entities across the network anyway.

Both client and server Lua with have a `loadWorld` function defined in a common file that will load all static world entities, making the client and server synchronized on boot. None of it needs to travel over the network.

serverIn
serverOut

clientIn
clientOut

Or just copy clientState and serverState to another Lua variable, set the originals to nil, then build the state to return to the client or server. This keeps the number of magic variable names few, should be efficient, and should be almost as easy to manage as a truly functional version (serverIn/serverOut).

The server should not send any of its entities to the client. The client should be able to create all its entities itself.


The client of course has entities that can be rendered. I think the server will not have the rendering mesh. Instead it will only have the collision mesh. This is determined by Lua. The client Lua loads rmsh files and the server loads cmsh files. I don't think there's any reason for the server to have the high resolution models unless it's doing collision handling with them.

On the client, entities are used for rendering and collision detection.
On the server, entities are used only for collision detection.
Entities are only for acceleration of slow or otherwise impossible tasks.


Perhaps I should make all servers have a password that is used for encryption and authentication. Clients could also have user names to allow for user whitelists. This would be done in C so that authentication can be handled before the connection is fully established. Encryption would be enabled before the first Lua object is sent.


Is there any reason to send an entity over the network when it could be emulated with Lua?


Any model is permitted to have a collision mesh. Collisions may be disabled in entities.


There's many methods of collision detection:
BSP
BVH
Octree

BSP works great for buildings, but requires a lot of work to implement.
BVH is easier, but seems like it works best with lots of sparse entities. It doesn't seem to be as good to me at splitting up models into smaller pieces.
Octree (a BVH with splits?) seems like it works well for any situation, but I'd have to implement it separately for the world of entities and for individual models.

Perhaps I can use BVH to select the model and Octree to select the region of polygons to act on?
An Elite-like or a bunch of cubes would work well with BVH. A Quake-like would be better with Octree.

One way to do this is to prototype it in Lua and see how slow it is. I would need a way to profile Lua though, so I should add a `clock` Lua function.
Actually, I probably shouldn't prototype it in Lua since I don't want Lua to need to know about the collision mesh faces. So let's start with naive engine-supported collision. If it's too slow, then try BVH.

That said, the actual first thing I need to do is figure out how to import a collision mesh into the engine.

There should be a cvar that renders collision meshes in a color that stands out.

Mesh collides with mesh. So it's O(M*N). That's why octrees and BVH is of interest.


CMSH and RMSH files are stored little endian.


I'd like normal people to be able to use the engine, so I need to figure out a way to make it easy to install and manage. Here's what I currently need to run a game called "game".
engine-1/
  cengine-1.exe
  sengine-1.exe
  SDL2-2.0.dll
  lua.dll
  enet.dll
  physfs.dll
  game.pk3
  autoexec.cfg
  workspace/

Here's the minimum I could get it to, ignoring all other factors:
engine-1/
  engine-1.exe
  game.pk3
  settings.cfg  -- Created by engine
  workspace/  -- Created by engine
    game/  -- Created by engine
      file.txt  -- Created by game

It would be nice if I could have the zip file in the executable, but it sounds like that's not practical.

Maybe I should just do it the way OpenArena does it, accept there's going to be a lot of files and distribute them in a zip file.


I think I will have a default texture: Hot pink


I don't think I like the structure of the scene graph.
I want entities to be more like groups, so I think I will rename `entity_t` to `scenegraph_group_t`. I think I will create a new type called `scenegraph_model_t`, which binds to a single `model_t` and can do things such as override the material and specify the position, orientation, and size. `model_t` will still have a default material. Or maybe I'll just leave it as is, which is pretty close to what I want, but I'll make it so model entities can only link to one model. Once multiple textures are working, then maybe I can rename all the "entity" stuff to "scenegraph".

group
model


I want to switch out sets of materials (each containing GLSL shader programs). Would that be called a shader? What do other engines call it?
Quake 3 would call it a shader.
Maybe I could use a GLSL shader to swap between pre-loaded textures?
Maybe I could allow Lua to create the uniforms it needs?
Maybe I could figure out some way to give Lua a high level of control of the shaders? Looking at the renderer, I'm not sure that's wise if I want to make it fast in the future. It would probably require Lua executing while rendering.


Alpha models need to be drawn last! I think the reason is that the z-buffer culls any pixels that are farther than the alpha pixels. So the opaque pixels need to be written first, then the alpha pixels are drawn over top. The alpha pixels will look at the pixels beneath them and apply a transparency function on them.


Frame rate plummets sometimes when I get the culling bug. Update: Frame rate plummets over time.
Reason: Every time an entity is created, it needs to be linked to a reachable entity. This increases the length of the `children` array. The framerate drop is noticeable with a length of ~1500. What needs to happen is that the deleted entity must be manually unlinked from its parent node.
There's a few ways to solve this.
* Force the user to manually unlink the entity from the parent entity.
* Make the entity point at its parent, and automatically unlink the entity when it is deleted.
This introduces a new problem though: an entity can have more than one parent entity.
* Make unlinking from a parent automatically delete the entity if its reference count is zero.
But what if I want an entity to be able to point at itself?
* Rendering a cyclic entity will terminate at N levels of recursion. Unlinking from a parent automatically deletes the entity if it is no longer reachable from a reachable entity.
But when was the last time you saw an "infinite" grid or space of objects placed at regular intervals? For me it was in a renderer demo on YouTube. I haven't ever seen it in the few games I've played. I think we can safely say no to tracing garbage collection.
Multiple parents pointing to an entity *would* be useful. Let's say you want five motorcycles. The frame is one entity, the handle bars are another entity, the wheels are two other entities. Well... actually that wouldn't be that useful. I would still need a bunch of different entities because the handle bars would be in different positions. Let's try no garbage collection...
Models can have multiple parents. They are never freed.
Each time an entity is linked to another entity, check to make sure that the child doesn't already have a parent. In fact, let's create the entity when we link it. Creation is linking.


function Model_construct(position, orientation, scale)
	local entity = Model(g_cameraEntity, g_boxModel)
	entity_setScale(entity, scale)
	entity_setPosition(entity, position)
	entity_setOrientation(entity, orientation)
    return entity
end

-- A group entity must always have a parent. Children are added by passing the group entity to the constructors of new entities.
g_cameraEntity = Group(g_worldEntity)

-- A model entity must always have a parent and a child.
terrainEntity = Model(g_cameraEntity, mesh_load("blender/terrain10"))
setScale(terrainEntity, 1100.0)
setPosition(terrainEntity, {x=0, y=0, z=2000})
setOrientation(terrainEntity, {w=1, x=-1, y=0, z=0})

g_entity = Model_construct({x=500, y=0, z=1000}, {w=1, x=-1, y=0, z=0}, 100.0)

-- Deleting the entity automatically unlinks it from its parent.
deleteEntity(g_entity)
g_entity = Model_construct({x=500, y=0, z=1000}, {w=1, x=-1, y=0, z=0}, 100.0)
local materials = {redMaterial, greenMaterial, blueMaterial}
local material = materials[((g_frame//60) % 3) + 1]
setMaterial(g_entity, material)


This feels robust to me.


I think collision detection for this game might be possible with just a hash table (a sparse 3D array) since block positions will be snapped to the grid.
Should I interpolate block positions like Pac-Man does?
Line tracing could be done with a line drawing algorithm.

For physics, each block can have a real position (snapped to the grid), a rendered position, and a velocity. When you drop a block, it smoothly accelerates as it falls, but the real position is always snapped to the grid. The rendered position does determine which point on the grid the block resides at though.


All this fun physics stuff I think I should leave for the end. For now, I need to figure out how to do basic grid collision handling. Perhaps I should start by creating the box the players are bound in and do collision handling and player movement with just that. I think I'll just hard code it like `player.position = vec3_clamp(player.mins, player.position, player.maxs)`.


Boxes and the world boundary should make collision handling reasonably easy. Velocity is split up into x, y, and z components and the movement for each is applied in order. Maybe the order would be xyz? Or zxy? Probably doesn't matter. Choose one and adjust jump velocity and gravity to compensate.


When a box is picked up, it checks to see if there is any box above it. If there is, then that box is shoved into the physics queue. When that box is simulated on the next frame, it does the same check, and the box above it is shoved into the physics queue.
The box in the player's inventory does not collide with anything.


I should add a SQL database for the boxes.
SQLite looks quite large though, maybe I should use a text file?

sqlite3_open
sqlite3_prepare_v2
sqlite3_step
sqlite3_column_*
sqlite3_finalize
(sqlite3_close?
 | sqlite3_close_v2?)
sqlite3_exec?
sqlite3_reset?
sqlite3_bind_*?

I think I should prepare SQL statements and then replace the parameters with the cube data on each run.

I think I will only allow one database per game and hard code the name.


I think I shouldn't be using mins/maxs for collision detection since I'm trying to base it off of a grid. Instead if I want mins/maxs then I should specify it in terms of cubes. The player is 2 cubes tall and 1 cube wide for example.


All blocks need to be sent to the client on connect. The server sends incremental block updates to all clients from then on. The client needs to simulate blocks in real time before the server has time to send the actual positions. Let's say there's 200 ms of delay between the player placing a block in midair and the server giving confirmation that the block was placed. And then the block should fall in sync on the client and server.

For placing a block, I could create a placeholder block of an unusual texture to show that it isn't actually there yet. When the server confirms that the block has been placed, the block gets its proper texture. In this case, I think I would simulate on the client independently of the server. It's easier, and I don't think falling blocks need to be synchronized with the server. I don't think players will try to grab falling blocks often.

Player movement should be synchronized though to some extent. I'm not exactly sure how to synchronize that. Does the client calculate the error for a past snapshot and then apply that error to all newer snapshots?


The server will send events to all clients.


I could have a QR code in game that links to instructions on my website.


Maybe player models could be Minecraft-style slimes? Those are fun.


The server is dropping packets because instead of collecting them, it just overwrites the last parsed one. I think the client does this too, but I think it's running at a higher framerate.


When the player picks up the box, it should be shown inside the cursor. It should be hidden from all other players. When the player places the box, all other players should see it disappear.

Perhaps don't even do collision handling on the server? Maybe it should all be client side and the server and client only communicate in order to color and move boxes. It's not like you can cheat in this "game".

Events:
create box {position, color} Write to database.
create initial box {position, color}
move box {start position, end position} Write to database.
change box color {position, color} Write to database.

And that is all. The server doesn't even need to know where the client is. This means I don't have to worry about client-side prediction! I do have to simulate boxes on the server though so that clients selecting boxes don't select air when they think they are selecting a box. Boxes actually need to fall on the server.


Alpha gives transparency. Translucency is alpha, plus a blur.


server
 serverState
 clientState[numClients][snaps]
client
 clientState
 serverState[snaps]


For now, I will assume the database already exists.


The database must have an alphanumeric name and be in the root of the workspace. The .db extension is automatically appended to the name. The reason for this is that it's not easy to make SQLite use Physfs, and it's not easy to tell whether a file read using Physfs exists in a zip file or on the file system.


e = str4_format(&path, "%4/%4/%s.db", &g_workspace, &g_game, lua_tostring(l, 1));


How the database was created:
CREATE TABLE boxes (
	id INTEGER  PRIMARY KEY,
    color TEXT,
    x REAL,
    y REAL,
    z REAL
) STRICT;
-- Optional:
CREATE INDEX position ON boxes(x, y, z);

SELECT * FROM boxes WHERE id == $id;

INSERT INTO boxes(color, x, y, z) VALUES ($color, $position.x, $position.y, $position.z);

UPDATE boxes SET color = $color WHERE id == $id;
UPDATE boxes SET x = $position.x, y = $position.y, z = $position.z WHERE id == $id;
UPDATE boxes SET x = $position.x, y = $position.y, z = $position.z WHERE x == $oldPosition.x AND y == $oldPosition.y AND z == $oldPosition.z;


How to map SQLite tables to Lua tables?

Type Box = struct {
	int id;
    Str4 color;
    double x;
    double y;
    double z;
};
Type Boxes = Box[];


SQLite REAL is stored as `double`, which is the same as what Lua stores. So moving numbers between Lua and SQLite shouldn't introduce conversion errors.


CREATE TABLE users (
	id INTEGER  PRIMARY KEY,
    name TEXT,
    password TEXT
) STRICT;

And obviously I can't commit this table. :)


I don't I need to bother with transactions because I'm only doing updates to one row at a time.


I will need a loading screen. During that time I must inhibit client input.

I believe the reason that download is so long is because I have so much data I am sending as Lua objects over Enet as UDP. I believe the reason the client still updates while it is downloading is because ENet breaks up the massive message into smaller packets, sends them over a period of time (the waiting time) and reassembles the message on the client. This means that ENet has full control over the downloading delay, and I can't show progress.

Haha, I can make the loading screen a cube with a texture that says "loading..." on it. Moving the mouse rotates the cube. I'm surprised that putting some thought into the loading screen actually resulted in an interesting idea. I thought I would just get "show loading message on screen" like I originally wanted.





Custom data for each package, server:
    identity.cfg
    client.cfg

Stuff I need to add before public release:
    Make movement mostly framerate independent.
    Add more textures?
    Sort transparent models?
    Windows test
    Multiple architecture test?
    Final package

Stuff I need to document:
    Rmsh & script
    Cmsh & script
    Lua's `include`, especially its relative path behavior.
    All Lua functions
    All cvars and console language
    Key binding
    SQLite bindings

Stuff I need to add:
    Collision detection
    Dynamic lighting
    Light maps
    Improved Lua error reporting
    Compression
    Encryption
    Authentication

Graphics stuff I dream of adding:
    Light map
    Dynamic lighting
    Curves
    Bump mapping
    HDR or similar
    Parallax mapping
    Portals

Other improvements:
    Use hash table for cvars.
    Replace scripting language with something like Lua or DuckLisp.
    Do delag and prediction.
    Be more restrictive with system resources.

[*] (Client) Get something on the screen using SDL
--------------------------------------------------
[*] (Client) Call C functions from Lua
[*] (Server) Call C functions from Lua
-----------------------------------------------
[*] (Common) Load and parse Wavefront OBJ files
[*] (Common) Load and parse config files
[*] (All)    Get on those TODOs (ugly ones)
[*] (Common) Create virtual file system
    [*] (Common) Create file_concatenatePath()
    [*] (Common) Only allow file paths that remain in the workspace
[/] (Common) Load and parse Wavefront MTL files
[/] (Common) Load and parse Oolite DAT files
[*] (Common) Create entity tree from Lua
    [*] (Common) Set position and orientation from Lua.
[/] (Server) Send entity tree over the network
    [*] (All) Decide on network protocol
    [*] (Client Server) Send and receive packet over the network.
    [/] (Client Server) Send and receive packets reliably over the network.
    [*] (Server) Send entity tree over the network.
[*] (Client) Receive entity tree from the network
[*] (All)    Get on those TODOs (ugly ones)
[*] (Client) Render entity tree in basic 3D using OpenGL
--------------------------------------------------------------
![ ] (Client) Pass entity tree through VM and back to renderer
[*] (Server) Send entity tree every second
[*] (Server) Animate entity tree
[*] (All)    Get on those TODOs (ugly ones)
[*] (Client) Render tree every time it is received
[*] (Client) Optimize rendering
-------------------------------
[*] (All) Get modding working.
    [*] (All) Load base game.
    [*] (All) Load multiple mods.
!    [ ] (All) Merge source code from multiple mods.
!    [ ] (All) Execute cached/merged files instead of latest files.
------------------------------------------------------------------
[*] (Client) Get keyboard input
    [*] Get keys from SDL2.
    [*] Implement key binding.
        [*] Create scripting command that sets callbacks.
        [*] Create `bind` scripting command.
    [*] Send keys to Lua.
        [*] Allow Lua to manipulate and read scripting variables and callbacks.
[/] (Client) Get mouse input
[*] (Client) Send input
    [*] Allow Lua to send arbitrary network messages using unreliable packets.
    [*] Make server communicate with clients individually.
![ ] (All)    Get on those TODOs (ugly ones)
[*] (Server) Receive input
[*] (Server) Make an entity move based on input
-----------------------------------------------
[*] (All) Fix memory allocation problems.
[*] (Client) Attach camera to moving entity
    [*] (Server) Send Lua table to client
    [*] (Server) Send position and orientation to client
=================================================
*** engine-1 is now officially a game engine. ***
=================================================
[*] (Common) Implement proper VFS.
[*] (Common) Redo config scripting system.
[ ] (Client) Load GLSL from files.
[ ] (Client) Allow GLSL to include GLSL libraries (preprocessor).
[*] (Common) Allow Lua to include Lua source code.
[*] (Common) Import .obj files.
===========================
*/* Start work on games. ***
===========================
[/] (Client) Texture models.
    [*] (Client) Load images.
    [*] (Client) Create texture list.
    [*] (Client) Bind texture to model.
    [ ] (Client) Bind texture to entity.
    [*] (Client) Render texture.

=====================
*/* Boxes sandbox ***
=====================
[/] (Art) Make models
    [*] Make boxes
	[*] Make map
	[ ] Make player models
[ ] (Lua) Texture boxes with different colors corresponding to the keyboard numbers 0-9.
[*] (Lua) Add physics and collision handling.
[ ] (All) Profile and optimize for speed.

=========================
*/* Multiplayer Elite ***
=========================
[ ] (Lua)    Load Asteroid model.
[ ] (Lua)    Procedurally generate universe.
[ ] (Client) Create 2D reference entities.
[*] (Client) Create 3D reference entities.
[ ] (Lua)    Implement radar.
[ ] (All)    Add collision handling.
[ ] (Client) Add more correct looking lighting.

Expected leaks:
    220B    SDL_Init()

Remember this:
    git status | grep modified: | sed 's/\tmodified:   //'

Disallow Lua bytecode.
Exec files using a path relative to the current file's directory.
Hotplugging joysticks and controllers gives wrong ID.
Note: SDL_IsGameController seems to cause lag when run in the main game loop.
Note: Networking code is hard. Don't change types last minute. You will get bugs.
Note: Use consistent bit widths for integers. Don't rely on things like `unsigned int`. Instead use `uint64_t`.
