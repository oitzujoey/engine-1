
@TODO: Lines marked with an exlamation point in the first column are out-of-date.

Engine is the main game. It runs a secure VM and provides acceleration for slow operations and I/O.
Mod loader finds and selects resources and resolves conflicts. The final mod is placed in the main game directory.
Server browser finds servers and sends the selected one to the engine.
Supervisor runs each application and moves the necessary data between them.

Order of implementation:
    Engine - Game
        Server - Client
        Sgame - Cgame
    Mod loader
    Supervisor
    Master server
    Server browser

VM
    What we want to avoid:
        Access to the file system
        Access to external programs
        Access to the internet
        Spyware
    Languages
        QVM
            Works, but is binary, uses a niche compiler, and doesn't allow stacked mods.
        Java
            ?
        Python
            Not easily sandboxed? I should learn Python.
        LLVM
            Not easily sandboxed?
        Custom bytecode
            GCC/LLVM -> bytecode -> safe interpreter
        ECMAScript
            Every number is a float. I don't like it.

Pre-game
    Restricted variables can be set using pipe or arguments.
    Game code is loaded.
In-game
    Nearly any variable can be set and read.

Server will know the whole game state. Client will (ideally) only know what it can see. As much client information as practically possible should be presented to the player. This is an anti-cheat measure.

The client will setup the I/O, and then run the game script. The script will periodically call functions that the client provides.
The server will run the game script. The script will periodically call functions that the server provides.
The script is somewhat in charge of the framerate. I may or may not change that in the future. We don't want people mining Bitcoin in other people's games.

I'm thinking of keeping all geometry inside the engine. I don't think the game code needs it, and it would be a hassle to transfer it to Lua. If the game code needs a normal, I'll let it have the normal. It doesn't need any more than that though. All collision detection will be done in the engine itself.

Do *any* config; lock restricted settings; start lua; do limited config

!Client system calls
!    get_user_input
!        Keyboard, mouse, and joystick
!    add_entity
!        Tell renderer to try drawing this entity.
!    render_scene
!    get_server_state
!        Get the server state from the network, named pipe, or carrier pigeon.
!    send_client state
!        Send the client state using the network, named pipe, or carrier pigeon.
!Server systems calls
!    get_client_state
!        Get the client state from the network, named pipe, or carrier pigeon.
!    send_server_state
!        Send the server state using the network, named pipe, or carrier pigeon.
!    load_map
!        Load the map into the given entity tree.

Lua may not execute config scripts, however, it may set config variables that it has permissions for.

Screenshots and videos both save as a dump of the game state. These game states can then be converted to images or videos.

Console will be fully integrated into the engine. No part of it will be in Lua. Lua can access the variables, but it cannot run commands.

Client config vars will be initialized to whatever is required, but the server will then send additional vars to create. If a var already exists, it will be overwritten.

Client will know its own number.

The entity tree is created not by the engine, but by the Lua script. This allows for the script to either load a map from a file, or do something fancier like procedurally generate the map.
All objects are stored in a global array.
All materials are stored in a global array.


No entity truely contains any other entity. It may contain the addresses of several child entities, but the children will always be stored in the entity list.
Models may be treated as a child entity, but they cannot contain other entities, and they may not be placed in the entity list.
The entity list exists to keep track of all entities. It should prevent permanently lost entities that are unable to be freed, and it allows the game state to be sent to the client more easily and compactly. Once an entity is created, it will never be destroyed. It may be completely unlinked and placed on the deleted-entity list, but it will not be freed. When a new entity is asked for, the deleted-entity list will be checked first. If an entity is in that list, it will be resurrected and removed from that list. If the deleted-entity list is empty, a new entity will be created using malloc. Only during shutdown will the entities in the entity list be freed.
Models may be created, but not freed until game shutdown.

Lists:
    entity_t *world_g;
    model_t *model_g;

entity world_g {
    void *entities {
        entity {
            void *entities {
                entity ...,
                ooliteModel {
                    vec3_t *vertices;
                    int vertices_length;
                    vec3_t *faces;
                    int faces_length;
                    vec3_t *surfaceNormals; // Same length as "faces".
                }
            };
            int entities_length;
        },
        ...
    };
    int entities_length;
    subEntityType_t type[none, entity, ooliteModel] = entity;
}

Oolite .dat file format:
    NVERTS <number of vertices>
    NFACES <number of faces>
    
    VERTEX
    <(float[3]) vertex>
    ...
    
    FACES
    0 0 0 <(float[3]) face normal> || <"0 0 0"> 3 <(int[3]) vertex indices>
    ...
    
    TEXTURES
    <Texture index> 1.0 1.0 <(float[2]) texture coordinates[0]> <(float[2]) texture coordinates[1]> <(float[2]) texture coordinates[2]>
    ...
    
    NAMES <number of names>
    <Material name>
    ...
    
    NORMALS
    <(float[3]) normal>
    
    END



Required calls to manage the entity tree:
    bool l_fileExists(string fileName)
        Return true if file "fileName" exists.
    string l_getFileContents(string fileName)
        Return the contents of file "fileName".
    {int objectIndex, string objectName} l_loadOBJ(string fileName)
        Load OBJ file into engine. Returns the object array index and the object name. Index is -1 on error.
        MTL is loaded automatically if one is requested and exists.
    int l_entity_create(string name, int type)
        Adds an entity of name "name" and type "type". Returns the index.
    bool l_entity_delete(int index)
        Returns true if entity at index was successfully deleted.
    bool l_entity_addChild(int parent, int child)
        The index "child" will refer to the appropriate list based on the type of the parent entity.
        If entities can be linked and the operation is successful, then this function returns true.
        If the entities cannot be linked (possibly because of a hirarchy loop), this function returns false.
    bool l_entity_removeChild(int parent, int child)
        If entities can be unlinked and the operation is successful, then this function returns true.
        If entities cannot be unlinked (possibly because they weren't linked in the first place), then this function returns false.
    int l_loadOoliteModel(string fileName)

entity {
    int type
    void *children
    int children_length
    string_t name
    vec3_t origin
    vec4_t orientation
}

Communicating the game state must be fast. All other communications can occur slowly.

Server â†’ client gamestate commands
    Create entity
    Delete entity
    Set entity

!The above command list will be implemented in Lua. Determining what to send the client will be Lua's job. The packaging of it will be the engine's job.

After a map is loaded, the game state of both the client and the server should be the same. Diffs will then be sent to the client when appropriate.

I need to use UDP because it is real time, while TCP may do weird things with time. I'm essentially going to write my own ripped-off version of Carmack's protocol.

Server send
    C: Subtract most recently acknowledged state from current state.
        Subtraction should result in changes only and static values should cancel to zero. We need a protocol that has this characteristic.
    C: Place current state in queue.
    C: Compress difference.
    C: Send compressed difference.
Server receive
    C: Receive compressed difference.
    C: Inflate difference.
    C: Place difference in queue.
    C: Add current state to 


Coordinate system:
    vec3 is specified by "x,y,z".
    quat is specified by "w,x,y,z".
    1,0,0 points horizontally along the x axis.
    0,1,0 points horizontally along the y axis.
    0,0,1 points vertically along the z axis.
    Camera:
        1,0,0,0 points along the x axis. Camera x axis is along the y axis. Camera y axis is along the z axis. This only applies for the 1,0,0,0 orientation.


sgame will tell server what models to load. server will tell client what models to load. cgame might be able to check what models are loaded.


~100 packets/second - Determined by server variable. Server will send this value to the client.
~1000 millisecond timeout - Determined by server variable. Server will send this value to the client.
1400 MTU - Determined by server and client variables.

UDPv4 {
    16'source_port
    16'destination_port
    16'length
    16'checksum
    ?8'data
}

flags {
    1'encrypted
    1'compressed
    1'subtracted
}

server_data {
    8'command
}

client_data {
    8'command
}

server_header {
    16'id
    16'id_ack
    16'flags
    ?8'server_data
}

client_header {
    16'id
    16'id_ack
    16'flags
    ?8'client_data
}

if server {
    UDPv4.data:server_header
}

if client {
    UDPv4.data:client_header
}

Client commands:
    Dummy
    Join
    Set game input [float mouseX] [float mouseY] [bool keys[]] // The length of keys is NUMBER_OF_KEYS
    Disconnect
    Server console command [char command[]]
    Raw to lua [uint8_t message[]]
    Error
    
Server commands:
    Dummy
    Negotiate private key
    Enable encryption
    Set entity state [entityList_t entityList] [entity_t entityList.entities[]] [int entityList.deletedEntities[]] // Length of both arrays is stored in the entity list.
    Play sound [int soundNumber]
    Client console command [int length] [char command[]] // Not null terminated
    Raw to lua [int length] [uint8_t message[]] // Not null terminated
    Error

Dummy commands are too keep the connection alive when no data is being sent.
id_ack is the id of the message that is being referenced by the sender. The receiver must add this message to the just received one.
id & id_ack start at 0 and count up to ID_MAX. The value will then overflow to zero. ID_MAX and the timeout must be chosen such that id will not cycle through the entire sequence before a timeout occurs.
If a timeout occurs, 

init
    send "hello"
    negotiate key

send data
    message = send_queue.pop()
    sent_messages.push(message)
    message = subtract(message, last_acknowledged(received_messages))
    compress message
    encrypt message
    send message
    
receive data
    receive message
    decrypt message
    inflate message
    message = add(message, sent_messages[message.id_ack])
    set_acknowledge(received_messages[message.id_ack])
    received_messages.push(message)

Order is important. If the fields aren't set in the proper order, the subtraction trick won't work.
0.  Headers + Flags
<Start encryption>
1.  Entity state
*.  Misc commands
<End encryption>
-0. Signature


The purpose of config scripts is to set variables required to get the game running.
The purpose of the console is to do basic configuration of the client and server, however, making it an extensive debugging tool will also be a priority. 



Files to rewrite when it is somewhat working:
    obj
    file
    vfs
    str
    cfg (maybe)

[/] (Client) Get something on the screen using SDL
--------------------------------------------------
[*] (Client) Call C functions from Lua
[*] (Server) Call C functions from Lua
-----------------------------------------------
[*] (Common) Load and parse Wavefront OBJ files
[*] (Common) Load and parse config files
[*] (All)    Get on those TODOs (ugly ones)
[/] (Common) Create virtual file system
    [*] (Common) Create file_concatenatePath()
    [*] (Common) Only allow file paths that remain in the workspace
[/] (Common) Load and parse Wavefront MTL files
[/] (Common) Load and parse Oolite DAT files
[/] (Common) Create entity tree from Lua
    [*] (Common) Set position and orientation from Lua.
[ ] (Server) Send entity tree over the network
    [*] (All) Decide on network protocol
    [*] (Client Server) Send and receive packet over the network.
    [ ] (Client Server) Sand and receive packets reliably over the network.
    [ ] (Server) Send entity tree over the network.
[ ] (Client) Receive entity tree from the network
[ ] (All)    Get on those TODOs (ugly ones)
[ ] (Client) Render entity tree in basic 3D using OpenGL
-------------------------------------------------------------
[ ] (Client) Pass entity tree through VM and back to renderer
[ ] (Server) Send entity tree every second
[ ] (Server) Animate entity tree
[ ] (All)    Get on those TODOs (ugly ones)
[ ] (Client) Render tree every time it is received
--------------------------------------------------
[/] (Client) Get keyboard input
[/] (Client) Get mouse input
[ ] (Client) Send input
[ ] (All)    Get on those TODOs (ugly ones)
[ ] (Server) Receive input
[ ] (Server) Make an entity move based on input
-----------------------------------------------
[ ] (Client) Attach camera to moving entity
-------------------------------------------

Expected leaks:
    220B    SDL_Init()
