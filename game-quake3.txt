Second game?

Remote map option?
	This mode is disabled by default.
	When a map is loaded, the server checks for the map locally, and if it doesn't exist, it checks a mapserver for that map. If the map exists, the game server fetches the map, but does not write it to disk. The client will perform the same process to load the map. This will lead to long loading times both client and server side, but it also prevents users from having to download and store the map.

Surface attributes
	Friction
	Friction curve/type?
	Bounciness (OVERCLIP)
	Collision type (Noclip, Clip, Overbounce, Reverse)
	
collideNoclip:

collideClip:
	if (norm(velocity) == 0.0) {
		return
	}
	velocity -= (1.0 + surface.bounciness) * dotProduct(velocity, surface.normal) * velocity / norm(velocity)

collideOverbounce:
	originalSpeed = norm(velocity)
	if (originalSpeed == 0) {
		return
	}
	velocity -= dotProduct(velocity, surface.normal) * velocity / norm(velocity)
	error = normalize(velocity)
	if (error) {
		// Do something fun!
	}
	velocity *= originalSpeed * surface.bounciness

collideReverse:
	velocity = -velocity;

applyFriction:
	wish = normalize(wish)
	projection = dotProduct(wish, velocity) * wish
	normalProjection = velocity - projection
	velocity -= normalProjection * surface.friction
	speed = norm(velocity)
	if (speed > maxSpeed) {
		speed -= max(speed - surface.friction, maxSpeed)
		velocity -= projection
		normalize(projection)
		velocity += speed * projection
	}

Friction is applied when touching *any* surface. Friction is equal to force times the coefficient, so friction is applied when the player is on the ground, but also when the player is trying to move into a wall or even the ceiling.

A player's speed going into a teleporter is the same that comes out.
A player's velocity is rotated by the rotation attribute when teleporting.

World attributes:
	gravity
	tool effects multiplier
	acceleration

Movement:
	Q3?
	QW?
	No CPM
	No origami
	Glitch-like?
	QW/Glitch-like?
	No air acceleration
	Preliminary:
		No air acceleration
		
Tools:
	Slots for 4 tools
	Tools are user configured using tool files.
	Tools are partially map configured.
	Tools are specified by allocating a certain percentage to each attribute.
	Damage is calculated from projectile speed and knockback.
	Any number can be assigned to an analog attribute, but the vector that describes the attributes will be normalized after the tools file is parsed.
	Characteristics:
		Knockback (1 part/order of magnitude)
		Projectile speed (1 part/order of magnitude)
		Fire rate (1 part/order of magnitude)
		Is sticky (1 part)
		Bounces (1 part)
		Color (0 parts)
		Damage = (knockback) * vec3_dotProduct((projectile velocity), (player velocity))

A limited set of configurable tools allows many more weapon types than Q3A, but also keeps the player's set of choices low. It is expected that the players will keep several different configurations handy to easily swap tools out. A default set of tool configs will be supplied with the game.

Modes will be provided that allow or disallow client scripting.


Player visibility:
	Option 1: Could I render the scene, including all players, then rerender the players and check if any pixel is visible to the current player? This check would be done from the perspective of each player. The problem with this is it requires the server to render the scene to check visibility. A way to reduce the server load is to only render fragments that contain players, sort of like a bit blit. This also requires the resolution to be comparable to the client's resolution. This is the brute force approach.
		1.  Turn on depth test.
		2.  Render scene using default fragment shader.
		3.  Turn off depth test.
		4.  Render scene using player visiblity fragment shader.
			1.  If the player's fragment depth is less than gl_FragDepth, then return the current pixel, otherwise, return the current pixel and set the visibility uniform to true.
		5.  If the visibility uniform is true, send that player's coordinates to the player viewing the scene, otherwise, don't send the coordinates.
	Option 2: Trace an infinite ray from the camera to each non-player vertex in the scene. If the ray is stopped by a player and not a wall or map boundary, then send the coordinate to the client.
		Amendment 1: If the player's hitbox is visible, send the player's coordinates. Still requires determining if the player is visible.
		
